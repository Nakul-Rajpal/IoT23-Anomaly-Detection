import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
from constants import MODEL1, MODEL2, MODEL3
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader, TensorDataset
from sklearn.metrics import precision_score, recall_score, f1_score, confusion_matrix, roc_curve, auc

train_X = np.load("data/train_X.npy")
X_test_scaled = np.load("data/X_test_scaled.npy")
y_test = np.load("data/y_test.npy")

train_tensor = torch.tensor(train_X, dtype=torch.float32)
train_dataset = TensorDataset(train_tensor)
train_loader = DataLoader(train_dataset, batch_size=1024, shuffle=True)

model = MODEL1
model = model.to('cuda' if torch.cuda.is_available() else 'cpu')

criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=1e-3)
num_epochs = 20
device = 'cuda' if torch.cuda.is_available() else 'cpu'

losses = []
model.train()
for epoch in range(num_epochs):
    epoch_loss = 0.0
    for batch in train_loader:
        x = batch[0].to(device)
        optimizer.zero_grad()
        outputs = model(x)
        loss = criterion(outputs, x)
        loss.backward()
        optimizer.step()
        epoch_loss += loss.item() * x.size(0)

    avg_loss = epoch_loss / len(train_loader.dataset)
    losses.append(avg_loss)
    print(f"Epoch {epoch+1}/{num_epochs}, Loss: {avg_loss:.6f}")

X_test_tensor = torch.tensor(X_test_scaled, dtype=torch.float32).to(device)
model.eval()
with torch.no_grad():
    reconstructions = model(X_test_tensor).cpu().numpy()

reconstruction_errors = np.mean((X_test_scaled - reconstructions) ** 2, axis=1)

threshold = np.percentile(reconstruction_errors, 98)

y_pred = (reconstruction_errors > threshold).astype(int)

precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

print(f"\nThreshold: {threshold:.6f}")
print(f"Precision: {precision:.4f}")
print(f"Recall:    {recall:.4f}")
print(f"F1 Score:  {f1:.4f}")
print("Confusion Matrix:")
print(conf_matrix)

fpr, tpr, _ = roc_curve(y_test, reconstruction_errors)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(6, 5))
plt.plot(fpr, tpr, label=f"AUC = {roc_auc:.4f}")
plt.plot([0, 1], [0, 1], linestyle='--', color='gray')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("Anomaly Detection")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

